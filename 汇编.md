## 1. ARM汇编基础
前言


##### 1.1 寄存器,内存和栈
>在ARM汇编里,操作对象是寄存器,内存和栈
ARM的栈遵循先进后出,是满递减的,向下增长,也就是开口向下,新的变量被存到栈底的位置;越靠近栈底,内存地址越小
一个名为stackPointer的寄存器保存栈的栈底地址,成为栈地址.
可以把一个变量给入栈(push)以保存它的值,也可以让它出(pop栈),恢复变量的原始值.在实际操作中,栈地址会不断变化;但是在执行一块代码的前后,栈地址应该是不变的,不然程序就要出问题,

##### 1.2 特殊用途的寄存器
>ARM处理器中的部分寄存器有特殊用途 如下所示:  

>寄存器	| 用途
--- 	| 	-----
R0-R3 	| 传递参数与返回值
R7 		| 帧指针,指向母函数于被调用子函数在栈中的交接
R9 		| 在iOS3.0以前被系统保留
R12		| 内部过程调用存储器,dynamic linker会用到它
R13		| sp寄存器
R14		| LR寄存器,保存函数返回地址
R15 	| PC寄存器

##### 1.3 分支跳转与条件判断


>处理器名为"Program counter"(简称PC)的寄存器用于存放下一条指令的地址.一般情况下,计算机一条接一条地顺序执行指令,处理器执行完一条指令后将PC加1,让它指向下一条指令.(1-1)
处理器顺序执行指令1到指令5(2-2),但是如果把PC的值变一变,指令执行的顺序就完全不同

>指令执行顺序被打乱,变成了指令1,指令5,指令4,指令2,指令3,指令6,这种乱序的学名叫做"分支",或者"跳转",它使循环和subroutime成为可能,例如:
>
	```
	// endless() 函数
	endless:
		操作  操作数1, 操作数2
		分支  endless
		返回  // 死循环,执行不到这里啦!
	```
>在实际情况中,满足一定条件才得以触发的分支是最实用的,这种分支成为条件分支.if else 和 while都是基于条件分支实现的,在ARM汇编中,分支的条件一般有4种:

* □ 操作结果为0(或不为0);
* □ 操作结果为负数;
* □ 操作结果有进位;
* □ 运算溢出(比如两个正数相加得到的数超过了寄存器位数).

>这些条件的判断准则(falg)存放在程序状态寄存器(Program Status Register,PSR)中,数据处理相关指令会改变这些flag,分支指令再根据这些flag决定是否跳转.下面的伪代码展示了一个for循环
>
```
for:
	相加   A,#1
	比较	A,#16
	不为0则跳转到for
	/* 此循环将A和#16作比较,如果两者不相等,则将A加1,继续比较.
	 如果两者相等,则不再循环,继续往下执行. */
```

## 2. ARM/THUMB指令解读

>ARM处理器用到的指令集分为ARM和THUMB两种:ARM指令长度均为32bit,THUMB指令长度为16bit.所有指令可大致分为三类,分别为,数组操作指令,内存操作指令和分支指令.

##### 2.1 数据操作指令
>数据操作指令有以下2条规则:

>>* 所有的操作数均为32bit;
>>* 所有的结果均为32bit,且只能存放在寄存器当中.
总的来说,数据操作指令的基本格式是:

>```
>cp{cond}{s} Rd,Rn,Op2
>```

其中,"cond"和"s"是另个可悬后缀;"cond"的作用是指定指令"op"在什么条件下执行,共有17中条件: 

指令	| 条件
--- 	| 	---
EQ 		| 	结果为0(EQual to 0)
NE 		|	结果不为0(Not Equal to 0) 
CS 		| 	有进位或借位(Carry Set)
HS		|	同CS(unsigned Higer or Same)
CC		| 	没有进位或借位(Carry Clear)
LO		|  	同CC(unsigned LOwer)
MI		| 	结果小于0(MInus)
PL		| 	结果大于等于0(PLus)
VS		| 	溢出(Overflow Set)
VC		| 	无溢出(Overflow Clear)
HI		| 	无符号比较大于(unsigned HIger)
LS		|  	无符号比较小于等于(unsigned Lower or Same)
GE		| 	有符号比较大于等于(signed Greater than or Equal)
LT		| 	有符号比较小于(signed Less Than)
GT		| 	有符号比较大于(signed Greater Than)
LE		| 	有符号比较小于等于(signed Less than or Equal)
AL		| 	无条件(Always,默认)

"cond"的用法很简单,例如:

```
比较 R0, R1
移动 GE R2, R0
移动 LT R2, R1
```

比较R0和R1的值,如果R0大于等于R1,则R2 = R0;否则R2 = R1.
"s"的作用是指定指令"op"是否设置了flag,共有下面4中flag:
N(Negative)
如果结果小于0则置1,否则置0;

Z(zero)
如果结果是0则置1,否则置0;

C(Carry)
对于加操作(包括CMN)来说,如果产生进位则置1,否则置0;对于减操作(包括CMP来说),Carry相当于Not-Borrow,如果产生借位则置0,否则置1;对于有移位的非加/减操作来说,C置移出值得最后一位;对于其他的非加/减操作来说,C的值一般不变;

V(overflow)如果操作导致溢出,则置1,否则置0

>需要注意一点的是,C flag表示无符号数运算结果是否溢出;V flag表示有符号数运算结果是否溢出.

算数操作指令可以大致分为4类:

* 1.算数操作

> ADD R0,R1,R2; ------------------> R0 = R1 + R2

> ADC R0,R1,R2; ------------------> R0 = R1 + R2 + C(array)

> SUB R0,R1,R2; ------------------> R0 = R1 - R2

> SBC R0,R1,R2; ------------------> R0 = R1 - R2 - !C

> RSB R0,R1,R2; ------------------> R0 = R2 - R1

> RSC R0,R1,R2; ------------------>  R0 = R2 - R1 - !C

>算数操作中,ADD和SUB为基础操作,其他均为两者的变种.RSB是"Reverse Sub"的缩写,仅仅是把SUB的两个操作数调换了位置而已;以"C"结尾的变种代表没有进位和借位的加减法,当产生进位或者借位时,将Carrry flag 置为1.

* 2.逻辑操作


> AND R0,R1,R2; ------------------> R0 = R1 & R2

> ORR R0,R1,R2; ------------------> R0 = R1 | R2

> EOR R0,R1,R2; ------------------> R0 = R1 ^ R2

> BIC R0,R1,R2; ------------------> R0 = R1 &~ R2

> MOV RO,R2;    ------------------> R0 = R2

> MVN R0,R2;    ------------------> R0 = ~R2

>逻辑操作指令都已经用C操作符说明了作用,但是C操作符里的移位操作并没有对位的逻辑操作指令,ARM采用了桶式移位,共有四种指令:

>LSL 逻辑左移 ![逻辑左移](http://o7pqb42yk.bkt.clouddn.com/LSL.jpg)

>LSR 逻辑右移 ![逻辑右移](http://o7pqb42yk.bkt.clouddn.com/lsr.jpg)

>ASR 算术右移 ![算术右移](http://o7pqb42yk.bkt.clouddn.com/asr.jpg)

>ROR 循环右移 ![循环右移](http://o7pqb42yk.bkt.clouddn.com/ROR.jpg)

* 3.比较操作
>CMP R1,R2;  ------------------> 执行R1 - R2并依结果设置flag

>CMN R1,R2;  ------------------> 执行R1 + R2并依结果设置flag

>TST R1,R2;  ------------------> 执行R1 & R2并依结果设置flag

>TEQ R1,R2;  ------------------> 执行R1 ^ R2并依结果设置flag

> 比较操作其实就是改变flag的算术操作或逻辑操作,只是操作结果不保留在寄存器里而已.

* 4.乘法操作

> MUL R4,R3,R2    ------------------> R4 = R3 * R2

> MLA R4,R3,R2,R1 ------------------> R4 = R3 * R2 + R1
 
>乘法操作的操作数必须来自寄存器


##### 2.2 内存操作指令
内存操作指令的基本格式是:
op{cond}{type} Rd,[Rn,Op2]
其中Rn是基址寄存器,用于存放基地址;"cond"的作用与数据操作指令相同;"type"指定指令"op"操作的数据类型,共有四种:
B(unsigned Byte)
无符号byte(执行时扩展到32bit,以0填充);

SB(signed Byte)
有符号byte(仅用于LDR指令;执行时扩展到32bit,以符号位填充);

H(unsigned Halfword)
无符号halfword(执行时扩展到32bit,以0填充);

SH(Signed Halfword)
有符号halfword(仅用于LDR指令;执行时扩展到32bit,以符号位填充).

如果不指定"type",则默认是word
ARM内存操作基础指令只有2个,LDR(loaD Register)将数据从内存中读出来,存到寄存器中;STR(STore Register)将数组从寄存中读出来,存到内存中.两个指令的使用情况如下:

* LDR

```
LDR Rt,[Rn {,#offset}];              Rt = *(Rn {+ offset}),{}代表可选
```

* STR

```

```

* STRD

```

```

* LDRD

```

```


##### 2.3 分支指令

##### 2.4 THUMB指令
